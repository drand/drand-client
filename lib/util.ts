import {ChainInfo} from './index'
// this is generated by the `precompile` npm script
// using the package.json version itself messes with the generated javascript, so it must be known
// at compile time
import {LIB_VERSION} from './version'

export function sleep(timeMs: number): Promise<void> {
    return new Promise(resolve => {
        if (!Number.isFinite(timeMs)) {
            throw new Error('Invalid sleep time: Must be a finite number');
        }
        if (timeMs <= 0) {
            resolve();
            return;
        }
        setTimeout(resolve, timeMs);
    });
}

export function roundAt(time: number, chain: ChainInfo): number {
    if (!Number.isFinite(time)) {
        throw new Error('Invalid time: Must be a finite number');
    }
    if (!chain || !chain.genesis_time || !chain.period) {
        throw new Error('Invalid chain info: Missing required fields');
    }
    
    const genesisTimeMs = chain.genesis_time * 1000;
    if (time < genesisTimeMs) {
        throw new Error(`Invalid time: Cannot request a round before the genesis time (${new Date(genesisTimeMs).toISOString()})`);
    }
    
    return Math.floor((time - genesisTimeMs) / (chain.period * 1000)) + 1;
}

export function roundTime(chain: ChainInfo, round: number): number {
    if (!Number.isFinite(round)) {
        throw new Error('Invalid round: Must be a finite number');
    }
    if (!chain || !chain.genesis_time || !chain.period) {
        throw new Error('Invalid chain info: Missing required fields');
    }
    
    round = Math.max(0, round);
    return (chain.genesis_time + (round - 1) * chain.period) * 1000;
}

export type HttpOptions = {
    userAgent?: string;
    headers?: Record<string, string>;
    timeout?: number;
};

// taking a separate `userAgent` param for backwards compatibility
export const defaultHttpOptions: HttpOptions = {
    userAgent: `drand-client-${LIB_VERSION}`,
    timeout: 30000, // 30 second default timeout
};

export async function jsonOrError<T>(url: string, options: HttpOptions = defaultHttpOptions): Promise<T> {
    if (!url || typeof url !== 'string') {
        throw new Error('Invalid URL: Must be a non-empty string');
    }

    const headers: Record<string, string> = {...(options.headers || {})};
    if (options.userAgent) {
        headers['User-Agent'] = options.userAgent;
    }

    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), options.timeout || defaultHttpOptions.timeout);

        const response = await fetch(url, {
            headers,
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return await response.json();
    } catch (error) {
        if (error instanceof Error) {
            if (error.name === 'AbortError') {
                throw new Error(`Request timeout after ${options.timeout || defaultHttpOptions.timeout}ms`);
            }
            throw new Error(`Failed to fetch ${url}: ${error.message}`);
        }
        throw new Error(`Failed to fetch ${url}: Unknown error`);
    }
}

export async function retryOnError<T>(fn: () => Promise<T>, times: number, delayMs: number = 1000): Promise<T> {
    if (!Number.isInteger(times) || times < 0) {
        throw new Error('Invalid retry count: Must be a non-negative integer');
    }

    try {
        return await fn();
    } catch (error) {
        if (times === 0) {
            throw error;
        }
        
        await sleep(delayMs);
        return retryOnError(fn, times - 1, delayMs);
    }
}
